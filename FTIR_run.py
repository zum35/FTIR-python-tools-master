"""
This class loads an xml file containing FTIR interferograms and converts them to spectra
It was written based on the xml files generated by Bruker's OPUS software. 


things to do next
- account for undersampling (p 7-8)
- determine the convolution method and boxcar for the spectrometer (p 8)

- validate difference against a file also processed and exported to excel
- write a catch for a double-sided acquisition (AQM) to error out
- change the pad factor keyword to be a multiple of the length of the input array
- change the pad factor to at least double the length of the input array
"""

filename = '2 6 - difluorophenylboronic acid - HEAT CALIBRATION - 10 kHz - res 2 - 22 deg.0 (sample and reference).xml'

class FTIR_run(object):
    def __init__(self,filename,reffile=None,**kwargs):
        self.ks = { # default keyword arguments
        'verbose': True, # toggle verbose
        'apodize_method':'blackman-harris-3', # apodization method to use
        'pad_factor': 16, # zero-padding factor (the list will be expanded to the size 2**factor)
        'scan_zero': 2, # the scan where the run starts
        'pcpoints': 512, # the number of points surrounding the zpd that will be used for phase correction
        }
        if set(kwargs.keys()) - set(self.ks.keys()): # check for invalid keyword arguments
            string = ''
            for i in set(kwargs.keys()) - set(self.ks.keys()):
                string += ` i`
            raise KeyError('Unsupported keyword argument(s): %s' %string)
        self.ks.update(kwargs) # update defaules with provided keyword arguments
        
        self.filename = filename
        self.b64 = __import__('base64')
        self.st = __import__('struct')
        self.np = __import__('numpy')
        from bisect import bisect_left as bl
        self.bl = bl # for convenience of calls
        if self.ks['verbose'] is True:
            self.sys = __import__('sys')
            self.sys.stdout.write('Loading %s into memory' %self.filename)
            self.sys.stdout.flush()
        from _apodizer import apodizer
        from FTIR import FTIR
        import xml.dom.minidom
        self.tree = xml.dom.minidom.parse(filename)
        
        if self.ks['verbose'] is True:
            self.sys.stdout.write(' DONE\n')
            self.sys.stdout.flush()        
        
        ##### figure out some way to tell the difference between a single scan and a multiscan file
        if len(self.tree.getElementsByTagName('AB')) > 0: # check whether single or multiple scans
            print self.tree.getElementsByTagName('AB')
            self.multiscan = False
            scann = 0 # scan number counter
        else:
            self.multiscan = True
        
        ptags = [ # paramter tags
        'Data_Parameters_IgSm__Multiple',
        'Data_Parameters_IgRf',
        'Data_Parameters_Trace__Multiple',
        'Acquisition_Parameters_Rf',
        'Optic_Parameters_Rf',
        'Optic_Parameters_',
        'Instrument_Parameters_Rf',
        'Sample_Parameters_',
        'Acquisition_Parameters_',
        'FT_-_Parameters_',
        'Instrument_Parameters_',
        'FT_-_Parameters_Rf'
        ]
        self.parameters = {}
        for tag in ptags:
            paramtree = self.tree.getElementsByTagName(tag)
            if len(paramtree) > 0:
                self.parameters[tag] = self.getparameters(paramtree[0])
        
        apdzrinst = apodizer(self.ks['apodize_method'])
        if self.ks['verbose'] is True:
            self.sys.stdout.write('%s\n' %apdzrinst)
        
        self.scans = {}        
        mscan = self.tree.getElementsByTagName('IgSm__Multiple')[0] # pull multiscan tree
        nscans = len(mscan.getElementsByTagName('Ydata')) # number of scans in multiscan
        for scan in mscan.getElementsByTagName('Ydata'): # extract the scan interferograms
            if self.multiscan is True:
                scann = self.ifs(scan.getAttribute('block'))
            if self.ks['verbose'] is True:
                try:
                    self.sys.stdout.write('\rProcessing scan #%d/%d %.1f%%' %(scann+1,nscans,float(scann+1)/float(nscans)*100.))
                except ValueError:
                    print '\nfigure out why this block is not numbered:',scann,type(scann),'\n'
            self.scans[scann] = {}
            vals = scan.getElementsByTagName('values')[0] # get values tree
            nvals = vals.getAttribute('numvalues') # extract the number of values in the string
            fmt = '<'+nvals+'f' # generate format code (little endian float)
            string = self.gettext(vals.childNodes) # get the string
            decoded = self.b64.decodestring(string) # decode the string
            lst = self.np.asarray(self.st.unpack(fmt,decoded)) # unpack the string into a list of values
            self.scans[scann]['interferogram'] = lst
            if self.multiscan is False: # if doing a hard counter
                scann += 1
            self.scans[scann]['ftir'] = FTIR(# apply the FTIR transformation to the interferogram
            lst,
            apdzr = apdzrinst,
            **self.ks
            ) 
            #if scann+1 > 0: # a catch to exit the loop after a given number of scans (debugging)
            #    self.sys.stdout.write(" BREAKING (because I'm impatient)")
            #    break # because I'm impatient
        # extract the reference spectrum
        IgRf = self.tree.getElementsByTagName('IgRf')[0]
        for scan in IgRf.getElementsByTagName('Ydata'):
            vals = scan.getElementsByTagName('values')[0]
            nvals = vals.getAttribute('numvalues')
            fmt = '<'+nvals+'f' # little endian float
            string = self.gettext(vals.childNodes)
            decoded = self.b64.decodestring(string)
            lst = self.np.asarray(self.st.unpack(fmt,decoded))
            self.ref = FTIR(lst,
            apdzr = apdzrinst,
            **self.ks
            )
        if self.ks['verbose'] is True:
            self.sys.stdout.write(' DONE\n')
            self.sys.stdout.flush()
        self.normalize() # calculate the transmittence spectra (divide each sample spectrum by the reference)
        #self.trns_to_abs() # convert the transmittence spectra to absorbance
        self.subtract_scans() # subtracts the t=0 scan from all scans
        self.x = self.np.linspace(self.parameters['Acquisition_Parameters_']['LFW'],self.parameters['Acquisition_Parameters_']['HFW'],2**(self.ks['pad_factor']-1))
        
    def __str__(self):
        return 'FTIR run instance of file "%s"' %self.filename
    def __repr__(self):
        return "%s('%s')" %(self.__class__.__name__,self.filename) 
    
    def chngzero(self,value):
        """changes the zero scan of the run and runs the subtract function again"""
        if self.ks['verbose'] is True:
            self.sys.stdout.write('Changing scan zero from %d to %d\n' %(self.ks['scan_zero'],value))
        self.ks['scan_zero'] = value
        self.subtract_scans()
    
    def getparameters(self,tree):
        """pulls all the instrument paramters from the xml file"""
        #gibberish = { # plain english interpretations of abbreviations
        #'DXU':'x unit (DXU)',
        #'NPT':'number of points along x (NPT)',
        #'FXV':'WN cutoff (FXV)',
        #'DAT':'date (DAT)',
        #'TIM':'time (TIM)',
        #'HFL':'high frequency limit (HFL)',
        #'INS':'instrument (INS)',
        #'EXP':'experiment name (EXP)',
        #'SNM':'spectrum name (SNM)',
        #'XPP':'experiment path (XPP)',
        #'VEL':'sample rate (VEL)',
        #'LFQ':'low frequency (LFQ)',
        #'HFQ':'high frequency (HFQ)',
        #}
        
        out = {}
        for param in tree.getElementsByTagName('parameter'):
            #if param.getAttribute('name') in out:
            #    print 'duplicate', param.getAttribute('name'), out[param.getAttribute('name')],gettext(param.childNodes)
            out[param.getAttribute('name')] = self.ifs(self.gettext(param.childNodes))
        return out
    
    def gettext(self,nodelist):
        """gets text from a simple XML object"""
        rc = []
        for node in nodelist:
            if node.nodeType == node.TEXT_NODE:
                rc.append(node.data)
        return ''.join(rc)
    
    def ifs(self,string):
        """tries to convert string to integer or float, else returns the string"""
        try:
            out = int(string)
        except ValueError:
            try:
                out = float(string)
            except ValueError:
                out = string
        return out
    
    def integrate(self,start,end,method='B'):
        """
        Integrates y values given x bounds in a paired set of lists (e.g. a m/z list and an intensity list)
        
        name: name of the peak being integrated (only used for warning purposes)
        start: float
            start x value
        end: float or None
            end x value
            None will return the nearest value to the provided start value
        x: list of x values
        y: list of y values (paired with x)
        
        method: sets the method of integration
            'A' returns the sum of the intensities between the y values and 0
            'B' returns the sum of the intensities between the base of the peak and the curve
            'J' returns the highest y value within the bounds
            'K' returns the highest y value within the bounds minus the local baseline
        
        returns: integral
        """
        out = []
        if end is None: # if only a start value is supplied, return closest to that value
            loc = self.locate_in_list(self.x,start)
            for scan in self.scans:
                out.append(self.scans[scan]['diff'][loc])
            return out
        else:
            l = self.locate_in_list(self.x,start,'greater')
            r = self.locate_in_list(self.x,end,'lesser')
            
            for scan in self.scans:
                if method == 'A':
                    tot = sum(self.scans[scan]['diff'][l:r])
                    out.append(tot)
                elif method == 'B':
                    yl = self.scans[scan]['diff'][l]
                    yr = self.scans[scan]['diff'][r]
                    line = lambda i: (yr-yl)/(end-start)*(i-l) + yl # define the straight line between the two points
                    area = 0
                    for ind in range(l,r+1): # take every y intensity on the IR curve and subtract the value on the line
                        area += self.scans[scan]['diff'][ind] - line(ind)
                    out.append(area)
                elif method == 'J':
                    raise ValueError('The method J has not been scripted yet')
                    out.append(max(self.scans[scan]['diff'][l:r]))
                elif method == 'K':
                    raise ValueError('The method K has not been scripted yet')
            return out
    
    def locate_in_list(self,lst,value,bias='closest',within=0.1):
        """
        Finds index in a sorted list of the value closest to a given value
        
        If two numbers are equally close, return the smallest number.
        roughly based on http://stackoverflow.com/questions/12141150/from-list-of-integers-get-number-closest-to-a-given-value
        
        lst: list
            list of values to search
        value: float or int
            value number to find
        bias: 'lesser','greater', or 'closest'
            default 'left'
            'lesser' will return the position of the value just less than the provided value
            'greater' will return the position of the value just greater than the provided value
            'closest' will return the index of the nearest value to the one provided
        within: float
            if the bias is closest, the position will only be returned if the position is this value away from the actual value
        """                
        pos = self.bl(lst, value)
        if pos == 0: # if at start of list
            return pos
        elif pos == len(lst): # if insertion is beyond index range
            return pos -1 
        if lst[pos] == value: # if an exact match is found
            return pos
        if bias == 'greater': # return value greater than the value (bisect_left has an inherent bias to the right)
            return pos
        if bias == 'lesser': # return value lesser than the provided
            return pos -1
        if bias == 'closest': # check differences between index and index-1 and actual value, return closest
            adjval = abs(lst[pos-1] - value)
            curval = abs(lst[pos] - value)
            if adjval > within and curval > within: # if the value is outside of the lookwithin bounds
                return None
            if adjval < curval: # if the lesser value is closer
                return pos-1
            if adjval == curval: # if values are equidistant
                return pos-1
            else:
                return pos
            
    def normalize(self):
        """normalizes the sample spectra to the reference spetrum"""
        if self.ks['verbose'] is True:
            self.sys.stdout.write('Generating transmittence spectra (normalizing scans to reference)')
        for scan in self.scans: # normalize to the reference
            self.scans[scan]['transmittence'] = self.scans[scan]['ftir']/self.ref #- 1.
        if self.ks['verbose'] is True:
            self.sys.stdout.write(' DONE\n')
            self.sys.stdout.flush()
    
    def plot2d(self,nsteps=10,srng='all',xlim = (1200,1500),zlim = 'Auto'):
        """
        plots a series of traces over the course of the entire run in order to visually locate changes of interest
        """
        import pylab as pl
        from matplotlib import cm
        pl.close()
        fig = pl.figure()
        ax = fig.add_subplot(111)
        l = self.locate_in_list(self.x,xlim[0],'greater') # find bounds based on xlim input
        r = self.locate_in_list(self.x,xlim[1],'lesser')
        x = self.x[l:r] # narrow x list
        colours = cm.winter(np.linspace(0,1,nsteps))
        #colours = cm.spring(np.linspace(0,1,nsteps)) # use linear colour map spring
        if srng == 'all':
            srng = (0,len(self.scans)-1)
        
        for ind,i in enumerate(np.linspace(srng[0],srng[1],nsteps)):
            ax.plot(x,self.scans[int(i)]['diff'][l:r],color=colours[ind],label='scan #%d' %i)
        ax.set_xlim(xlim[0],xlim[1])
        #if zlim == 'Auto':
        #    zlim = (self.np.amin(z),self.np.amax(z))
        #ax.set_zlim(zlim[0],zlim[1])
        
        ax.invert_xaxis()
        ax.set_xlabel('Wavenumber /cm-1')
        ax.set_ylabel('Difference from scan #%d' %self.ks['scan_zero'])
        pl.legend(loc=1)
        pl.show()
    
    def plot3d(self,xlim = (1200,1700),zlim = 'Auto'):
        """plots a 3d surface plot of the difference data"""
        import pylab as pl
        from mpl_toolkits.mplot3d import Axes3D
        from matplotlib import cm
        pl.close()
        fig = pl.figure()
        z = []
        l = self.locate_in_list(self.x,xlim[0],'greater') # find bounds based on xlim input
        r = self.locate_in_list(self.x,xlim[1],'lesser')
        x = self.x[l:r] # narrow x list
        for scan in self.scans: # extract z data
            z.append(self.scans[scan]['diff'][l:r])
        z = self.np.asarray(z) # convert to numpy array
        y = self.np.arange(0,len(self.scans))
        
        ax = fig.gca(projection='3d')
        ax.set_xlabel('Wavenumber')
        ax.set_ylabel('Scan Number')
        ax.set_zlabel('Difference')
        ax.set_xlim(xlim[0],xlim[1])
        if zlim == 'Auto':
            zlim = (self.np.amin(z),self.np.amax(z))
        ax.set_zlim(zlim[0],zlim[1])
        ax.invert_xaxis()
        X,Y = self.np.meshgrid(x,y)
        ax.plot_surface(X,Y,z, cmap=cm.cool,linewidth=0, )
        pl.show()

    def plotabsorbance(self,scan):
        """plots the specified scan"""
        if scan not in self.scans:
            raise IndexError('The scan %d is not in the run' %scan)
        import pylab as pl
        pl.close()
        fig = pl.figure()
        ax = fig.add_subplot(111)
        ax.plot(self.x,self.scans[scan]['transmittence'],label='scan #%d' %scan)
        ax.invert_xaxis()
        ax.set_xlabel('Wavenumber /cm-1')
        ax.set_ylabel('Intensity')
        pl.show()
    
    def plotdifference(self,scan):
        """plots the difference plot of the specified scan"""
        if scan not in self.scans:
            raise IndexError('The scan %d is not in the run' %scan)
        import pylab as pl
        pl.close()
        fig = pl.figure()
        ax = fig.add_subplot(111)
        ax.plot(self.x,self.scans[scan]['diff'],label='scan #%d' %scan)
        ax.invert_xaxis()
        ax.set_xlabel('Wavenumber /cm-1')
        ax.set_ylabel('Difference from scan #%d' %self.ks['scan_zero'])
        pl.show()
    
    def plotscan(self,scan):
        """plots the specified scan"""
        if scan not in self.scans:
            raise IndexError('The scan %d is not in the run' %scan)
        import pylab as pl
        pl.close()
        fig = pl.figure()
        ax = fig.add_subplot(111)
        ax.plot(self.x,self.scans[scan]['ftir'],label='scan #%d' %scan)
        ax.invert_xaxis()
        ax.set_xlabel('Wavenumber /cm-1')
        ax.set_ylabel('Intensity')
        pl.show()
    
    def plottransmittence(self,scan):
        """plots the specified scan"""
        if scan not in self.scans:
            raise IndexError('The scan %d is not in the run' %scan)
        import pylab as pl
        pl.close()
        fig = pl.figure()
        ax = fig.add_subplot(111)
        ax.plot(self.x,self.scans[scan]['transmittence'],label='scan #%d' %scan)
        ax.invert_xaxis()
        ax.set_xlabel('Wavenumber /cm-1')
        ax.set_ylabel('Intensity')
        pl.show()
    
    def subtract_scans(self,key='transmittence'):
        """
        calculates the difference between the first scan (defined in the kwargs) and the other scans
        key can be set to 'ftir' if the user wishes to bypass the normalization part of the script
        """
        if self.ks['verbose'] is True:
            self.sys.stdout.write('Subtracting scans')
        for scan in self.scans:
            self.scans[scan]['diff'] = self.scans[scan][key] - self.scans[self.ks['scan_zero']][key]
        if self.ks['verbose'] is True:
            self.sys.stdout.write(' DONE\n')
            self.sys.stdout.flush()
    
    def trns_to_abs(self):
        """converts the transmittence values to absorbance"""
        if self.ks['verbose'] is True:
            self.sys.stdout.write('Converting transmittence specta to absorbance spectra')
        absorb = lambda x: 2-np.log10(x) # lambda function to convert transmittence to absorbance
        for scan in self.scans:
            self.scans[scan]['absorbance'] = absorb(self.scans[scan]['transmittence'])
        if self.ks['verbose'] is True:
            self.sys.stdout.write(' DONE\n')
            self.sys.stdout.flush()
    
if __name__ == '__main__':
    import pylab as pl
    import numpy as np
    pl.close()
    
    run = FTIR_run(
    filename,
    #pad_factor = 16, # 2**factor
    #apodize_method = 'blackman-harris-7',
    #pcpoints = 64,
    )
    print run,'\n'
    
    
    peaks = {
    #'1':{'bounds':[1259.08,1264.07]}, # peak 1 (increases)
    #'1exact':{'bounds':[1261.11,None]}, # peak 1 exact wavenumber
    #'2':{'bounds':[1255.96,1258.75]}, # peak 2 (decreases)
    #'2exact':{'bounds':[1256.90,None]}, # peak 2 exact
    #'3':{'bounds':[1444.5,1447.49]}, # peak 3 (decreases)
    #'3exact':{'bounds':[1446.29,None]}, # peak 3 exact
    'Marc':{'bounds':[1430.28,1450.40]}, # the ones that Marc used
    }
    
    for peak in peaks:
        peaks[peak]['trace'] = run.integrate(peaks[peak]['bounds'][0],peaks[peak]['bounds'][1])
    
    #pl.plot(peaks['Marc']['trace'],label='method B')
    ##marca = run.integrate(1430.28,1450.40,'A')
    ##pl.plot(marca,label='method A')
    #pl.legend()
    #pl.show()
    
    from kinetics_from_trace import fit_kinetics
    for peak in peaks:
        res,Rsq = fit_kinetics(
            np.linspace(0,5004.784001,2501),
            peaks[peak]['trace'],
            genplot=True,
            order=0
            )
        #peaks[peak]['fit'] = 


